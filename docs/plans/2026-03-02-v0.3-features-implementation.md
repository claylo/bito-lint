# v0.3 Features Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Ship three features for v0.3.0: broader config discovery (`.bito` names), region-level suppression filtering, and custom content entries with CLI + MCP exposure.

**Architecture:** Config discovery is foundational — change `find_project_config` to `find_project_configs` returning a `Vec`, merge all found files via figment. Suppression filtering adds sentence/paragraph-to-line mapping in `text.rs` and post-analysis filtering in `lint.rs`. Custom content adds a `CustomEntry` config struct, a `custom` CLI subcommand, and a `get_custom` MCP tool.

**Tech Stack:** Rust 2024 edition, figment (config), clap (CLI), rmcp (MCP), schemars (JSON schema), owo-colors (CLI output), camino (UTF-8 paths).

---

### Task 1: Broader Config Discovery — `find_project_configs` Returns Vec

**Files:**
- Modify: `crates/bito-lint-core/src/config.rs:240-268` (ConfigSources struct)
- Modify: `crates/bito-lint-core/src/config.rs:408-441` (find_project_config → find_project_configs)
- Modify: `crates/bito-lint-core/src/config.rs:349-389` (load method)
- Test: `crates/bito-lint-core/src/config.rs` (existing tests + new)

**Step 1: Write failing tests for `.bito` discovery**

Add these tests to the existing `mod tests` in `config.rs`:

```rust
#[test]
fn bito_config_discovered() {
    let tmp = TempDir::new().unwrap();
    let config_path = tmp.path().join(".bito.toml");
    fs::write(&config_path, r#"log_level = "debug""#).unwrap();

    let tmp_path = Utf8PathBuf::try_from(tmp.path().to_path_buf()).unwrap();

    let (config, sources) = ConfigLoader::new()
        .with_user_config(false)
        .without_boundary_marker()
        .with_project_search(&tmp_path)
        .load()
        .unwrap();

    assert_eq!(config.log_level, LogLevel::Debug);
    assert!(!sources.project_files.is_empty());
}

#[test]
fn bito_lint_overrides_bito_config() {
    let tmp = TempDir::new().unwrap();
    // .bito.toml sets debug
    fs::write(tmp.path().join(".bito.toml"), r#"log_level = "debug""#).unwrap();
    // .bito-lint.toml sets warn — should win
    fs::write(tmp.path().join(".bito-lint.toml"), r#"log_level = "warn""#).unwrap();

    let tmp_path = Utf8PathBuf::try_from(tmp.path().to_path_buf()).unwrap();

    let (config, sources) = ConfigLoader::new()
        .with_user_config(false)
        .without_boundary_marker()
        .with_project_search(&tmp_path)
        .load()
        .unwrap();

    assert_eq!(config.log_level, LogLevel::Warn);
    assert_eq!(sources.project_files.len(), 2);
}

#[test]
fn bito_and_bito_lint_merge() {
    let tmp = TempDir::new().unwrap();
    // .bito.toml sets dialect
    fs::write(tmp.path().join(".bito.toml"), "dialect = \"en-gb\"\n").unwrap();
    // .bito-lint.toml sets log_level — both should be present
    fs::write(tmp.path().join(".bito-lint.toml"), r#"log_level = "warn""#).unwrap();

    let tmp_path = Utf8PathBuf::try_from(tmp.path().to_path_buf()).unwrap();

    let (config, _sources) = ConfigLoader::new()
        .with_user_config(false)
        .without_boundary_marker()
        .with_project_search(&tmp_path)
        .load()
        .unwrap();

    // Both values merged
    assert_eq!(config.log_level, LogLevel::Warn);
    assert_eq!(config.dialect, Some(Dialect::EnGb));
}
```

**Step 2: Run tests to verify they fail**

Run: `cargo nextest run -E 'test(config::tests::bito_config_discovered)' -E 'test(config::tests::bito_lint_overrides_bito_config)' -E 'test(config::tests::bito_and_bito_lint_merge)'`
Expected: compile error — `project_files` doesn't exist yet.

**Step 3: Change `ConfigSources` to use `project_files: Vec`**

In `config.rs`, change:

```rust
// Before (line ~247):
pub struct ConfigSources {
    pub project_file: Option<Utf8PathBuf>,
    pub user_file: Option<Utf8PathBuf>,
    pub explicit_files: Vec<Utf8PathBuf>,
}

// After:
pub struct ConfigSources {
    /// Project config files found by walking up, ordered low→high precedence.
    pub project_files: Vec<Utf8PathBuf>,
    pub user_file: Option<Utf8PathBuf>,
    pub explicit_files: Vec<Utf8PathBuf>,
}
```

Update `primary_file()`:

```rust
pub fn primary_file(&self) -> Option<&Utf8Path> {
    self.explicit_files
        .last()
        .map(Utf8PathBuf::as_path)
        .or_else(|| self.project_files.last().map(Utf8PathBuf::as_path))
        .or(self.user_file.as_deref())
}
```

**Step 4: Change `find_project_config` to `find_project_configs`**

Replace the current `find_project_config` method:

```rust
/// Application names to search for config files (in precedence order, lowest first).
const APP_NAMES: &[&str] = &["bito", "bito-lint"];

/// Find project config files by walking up from the given directory.
///
/// Returns all matching config files from the closest directory that has any
/// match, ordered low-to-high precedence: `bito` names before `bito-lint` names.
fn find_project_configs(&self, start: &Utf8Path) -> Vec<Utf8PathBuf> {
    let mut current = Some(start.to_path_buf());

    while let Some(dir) = current {
        let mut found = Vec::new();

        for app_name in APP_NAMES {
            for ext in CONFIG_EXTENSIONS {
                let dotfile = dir.join(format!(".{app_name}.{ext}"));
                if dotfile.is_file() {
                    found.push(dotfile);
                }

                let regular = dir.join(format!("{app_name}.{ext}"));
                if regular.is_file() {
                    found.push(regular);
                }
            }
        }

        if !found.is_empty() {
            return found;
        }

        // Check boundary marker
        if let Some(ref marker) = self.boundary_marker
            && dir.join(marker).exists()
            && dir != start
        {
            break;
        }

        current = dir.parent().map(Utf8Path::to_path_buf);
    }

    Vec::new()
}
```

**Step 5: Update `load()` to use `find_project_configs`**

Replace the project config section in `load()`:

```rust
// Add project configs (ordered low→high precedence)
if let Some(ref root) = self.project_search_root {
    let project_configs = self.find_project_configs(root);
    for pc in &project_configs {
        figment = Self::merge_file(figment, pc);
    }
    sources.project_files = project_configs;
}
```

**Step 6: Update `load_or_error()` to check `find_project_configs`**

Change the `has_project` check:

```rust
let has_project = self
    .project_search_root
    .as_ref()
    .map(|root| !self.find_project_configs(root).is_empty())
    .unwrap_or(false);
```

**Step 7: Fix existing tests that reference `project_file`**

Update all existing tests that assert on `sources.project_file` to use `sources.project_files`. For example:

- `test_project_config_discovery`: `assert!(!sources.project_files.is_empty())`
- `test_boundary_marker_stops_search`: `assert!(sources.project_files.is_empty())`
- `test_explicit_file_overrides_project_config`: `assert!(!sources.project_files.is_empty())`

**Step 8: Fix downstream consumers of `project_file`**

- `crates/bito-lint/src/commands/info.rs`: `ConfigInfo::from_config` uses `sources.primary_file()` — no change needed.
- `crates/bito-lint/src/commands/doctor.rs`: `DoctorReport::gather` uses `sources.primary_file()` — no change needed.

Both consume via `primary_file()` which already handles the new vec.

**Step 9: Run all tests**

Run: `cargo nextest run`
Expected: all pass including new `.bito` discovery tests.

**Step 10: Run clippy and fmt**

Run: `cargo fmt --all && cargo clippy --all-targets --all-features`

**Step 11: Commit**

```bash
git add crates/bito-lint-core/src/config.rs
git commit -m "feat: support .bito and bito config file names with figment merge"
```

---

### Task 2: Sentence-to-Line and Paragraph-to-Line Mapping

**Files:**
- Modify: `crates/bito-lint-core/src/text.rs:82-87` (add mapping functions near existing split functions)
- Test: `crates/bito-lint-core/src/text.rs` (existing test module)

**Step 1: Write failing tests for line maps**

Add to `mod tests` in `text.rs`:

```rust
#[test]
fn sentence_line_map_basic() {
    let text = "First sentence.\nSecond sentence.\nThird sentence.";
    let map = build_sentence_line_map(text);
    // 3 sentences, each starting on its own line
    assert_eq!(map.len(), 3);
    assert_eq!(map[0], 1); // "First sentence." starts on line 1
    assert_eq!(map[1], 2); // "Second sentence." starts on line 2
    assert_eq!(map[2], 3); // "Third sentence." starts on line 3
}

#[test]
fn sentence_line_map_multiple_sentences_one_line() {
    let text = "First. Second. Third.";
    let map = build_sentence_line_map(text);
    assert_eq!(map.len(), 3);
    // All on line 1
    assert_eq!(map[0], 1);
    assert_eq!(map[1], 1);
    assert_eq!(map[2], 1);
}

#[test]
fn sentence_line_map_with_blank_lines() {
    let text = "First sentence.\n\nSecond sentence on line 3.\n\nThird on line 5.";
    let map = build_sentence_line_map(text);
    assert_eq!(map.len(), 3);
    assert_eq!(map[0], 1);
    assert_eq!(map[1], 3);
    assert_eq!(map[2], 5);
}

#[test]
fn paragraph_line_map_basic() {
    let text = "Para one.\n\nPara two.\n\nPara three.";
    let map = build_paragraph_line_map(text);
    assert_eq!(map.len(), 3);
    assert_eq!(map[0], 1); // "Para one." starts on line 1
    assert_eq!(map[1], 3); // "Para two." starts on line 3
    assert_eq!(map[2], 5); // "Para three." starts on line 5
}

#[test]
fn paragraph_line_map_multiline_paragraphs() {
    let text = "First line.\nStill para one.\n\nPara two starts here.\nStill para two.";
    let map = build_paragraph_line_map(text);
    assert_eq!(map.len(), 2);
    assert_eq!(map[0], 1);
    assert_eq!(map[1], 4);
}

#[test]
fn empty_text_empty_maps() {
    assert!(build_sentence_line_map("").is_empty());
    assert!(build_paragraph_line_map("").is_empty());
}
```

**Step 2: Run tests to verify they fail**

Run: `cargo nextest run -E 'test(text::tests::sentence_line_map)' -E 'test(text::tests::paragraph_line_map)' -E 'test(text::tests::empty_text_empty_maps)'`
Expected: compile error — functions don't exist.

**Step 3: Implement `build_sentence_line_map`**

Add to `text.rs` after `split_paragraphs` (around line 87):

```rust
/// Build a mapping from sentence index (0-based) to source line number (1-based).
///
/// Uses the same sentence splitting as [`split_sentences`], then locates each
/// sentence's starting position in the original text to determine its line number.
pub fn build_sentence_line_map(text: &str) -> Vec<usize> {
    if text.trim().is_empty() {
        return Vec::new();
    }

    let sentences = split_sentences(text);
    let mut map = Vec::with_capacity(sentences.len());
    let mut search_start = 0;

    for sentence in &sentences {
        // Find this sentence's start in the original text
        let trimmed = sentence.trim();
        if let Some(pos) = text[search_start..].find(trimmed) {
            let abs_pos = search_start + pos;
            let line = text[..abs_pos].matches('\n').count() + 1;
            map.push(line);
            search_start = abs_pos + trimmed.len();
        } else {
            // Fallback: if we can't find it, use previous line or 1
            map.push(map.last().copied().unwrap_or(1));
        }
    }

    map
}

/// Build a mapping from paragraph index (0-based) to source line number (1-based).
///
/// Paragraphs are separated by blank lines (matching [`split_paragraphs`]).
pub fn build_paragraph_line_map(text: &str) -> Vec<usize> {
    if text.trim().is_empty() {
        return Vec::new();
    }

    let mut map = Vec::new();
    let mut line_num = 1;
    let mut in_paragraph = false;
    let mut blank_seen = true; // Start as true so first non-blank line starts a paragraph

    for line in text.lines() {
        if line.trim().is_empty() {
            if in_paragraph {
                in_paragraph = false;
            }
            blank_seen = true;
        } else if blank_seen || !in_paragraph {
            map.push(line_num);
            in_paragraph = true;
            blank_seen = false;
        }
        line_num += 1;
    }

    map
}
```

**Step 4: Run tests to verify they pass**

Run: `cargo nextest run -E 'test(text::tests)'`
Expected: all pass.

**Step 5: Commit**

```bash
git add crates/bito-lint-core/src/text.rs
git commit -m "feat: add sentence-to-line and paragraph-to-line mapping functions"
```

---

### Task 3: Region-Level Suppression Filtering in Lint Engine

**Files:**
- Modify: `crates/bito-lint-core/src/lint.rs` (add filtering logic after each check runs)
- Test: `crates/bito-lint-core/src/lint.rs` (existing test module)

**Step 1: Write failing tests for region-level suppression**

Add to `mod tests` in `lint.rs`:

```rust
#[test]
fn region_suppression_filters_grammar_findings() {
    let resolved = ResolvedChecks {
        grammar: Some(crate::config::GrammarRuleConfig {
            passive_max: None,
        }),
        ..Default::default()
    };
    // Line 1: directive, Line 2: passive sentence (suppressed), Line 3: re-enable, Line 4: passive (not suppressed)
    let content = "\
<!-- bito-lint disable grammar -->
The report was written by the team.
<!-- bito-lint enable grammar -->
The ball was thrown by the player.";

    let report = run_lint("doc.md", content, &resolved, &default_config()).unwrap();
    let grammar = report.grammar.expect("grammar should run");
    // Only the line-4 passive should survive filtering
    for pv in &grammar.passive_voice {
        // sentence_num for the suppressed sentence should have been filtered out
        // The unsuppressed passive on line 4 should remain
        assert!(pv.sentence_num > 0);
    }
    // At least one passive should survive (the line 4 one)
    assert!(
        grammar.passive_count >= 1,
        "unsuppressed passive should remain"
    );
}

#[test]
fn disable_next_line_filters_single_finding() {
    let resolved = ResolvedChecks {
        grammar: Some(crate::config::GrammarRuleConfig {
            passive_max: None,
        }),
        ..Default::default()
    };
    let content = "\
The cat sat on the mat.
<!-- bito-lint disable-next-line grammar -->
The report was written by the team.
The ball was thrown by the player.";

    let report = run_lint("doc.md", content, &resolved, &default_config()).unwrap();
    let grammar = report.grammar.expect("grammar should run");
    // Line 3 passive suppressed, line 4 passive should survive
    // The passive_voice vec should contain at most the line-4 finding
    for pv in &grammar.passive_voice {
        // If sentence maps to line 3, it should have been filtered
        // We can't check exact line, but passive_count should be ≤ 1
        assert!(pv.sentence_num > 0);
    }
}
```

**Step 2: Run tests to verify they fail**

Run: `cargo nextest run -E 'test(lint::tests::region_suppression)' -E 'test(lint::tests::disable_next_line)'`
Expected: FAIL — grammar findings from suppressed regions are still present.

**Step 3: Implement filtering in `run_lint`**

Import the new text functions at the top of `lint.rs`:

```rust
use crate::text;
```

After the grammar check block (around line 113-124), add filtering:

```rust
// --- grammar ---
let grammar_report = if let Some(ref gc) = resolved.grammar
    && !suppressions.is_fully_suppressed("grammar")
{
    let passive_max = gc.passive_max.or(config.passive_max_percent);
    let mut report = grammar::check_grammar_full(content, strip_md, passive_max)?;

    // Region-level suppression filtering
    if !suppressions.is_empty() {
        let sentence_map = text::build_sentence_line_map(content);
        report.issues.retain(|issue| {
            let line = sentence_map.get(issue.sentence_num.saturating_sub(1)).copied().unwrap_or(0);
            !suppressions.is_suppressed("grammar", line)
        });
        report.passive_voice.retain(|pv| {
            let line = sentence_map.get(pv.sentence_num.saturating_sub(1)).copied().unwrap_or(0);
            !suppressions.is_suppressed("grammar", line)
        });
        // Recompute aggregates
        report.passive_count = report.passive_voice.len();
        report.passive_percentage = if report.sentence_count > 0 {
            (report.passive_count as f64 / report.sentence_count as f64) * 100.0
        } else {
            0.0
        };
        report.over_max = passive_max.is_some_and(|max| report.passive_percentage > max);
    }

    if report.over_max {
        pass = false;
    }
    Some(report)
} else {
    None
};
```

Do the same for `analyze` report's sub-reports that carry sentence/paragraph numbers. After `run_full_analysis` returns the report, filter its nested reports:

```rust
// After let report = analysis::run_full_analysis(...)?;
// Filter analysis sub-reports with location data
if !suppressions.is_empty() {
    let sentence_map = text::build_sentence_line_map(content);
    let paragraph_map = text::build_paragraph_line_map(content);
    filter_analysis_report(&mut report, &suppressions, &sentence_map, &paragraph_map);
}
```

Add a helper function:

```rust
/// Filter findings from a `FullAnalysisReport` using suppression regions.
///
/// Only filters sub-reports that have per-finding location data.
/// Aggregate-only reports (pacing, transitions, etc.) are not touched.
fn filter_analysis_report(
    report: &mut analysis::FullAnalysisReport,
    suppressions: &directives::SuppressionMap,
    sentence_map: &[usize],
    paragraph_map: &[usize],
) {
    // Grammar sub-report (sentence-level)
    if let Some(ref mut grammar) = report.grammar {
        grammar.issues.retain(|issue| {
            let line = sentence_map.get(issue.sentence_num.saturating_sub(1)).copied().unwrap_or(0);
            !suppressions.is_suppressed("grammar", line)
        });
        grammar.passive_voice.retain(|pv| {
            let line = sentence_map.get(pv.sentence_num.saturating_sub(1)).copied().unwrap_or(0);
            !suppressions.is_suppressed("grammar", line)
        });
        grammar.passive_count = grammar.passive_voice.len();
        if grammar.sentence_count > 0 {
            grammar.passive_percentage =
                (grammar.passive_count as f64 / grammar.sentence_count as f64) * 100.0;
        }
    }

    // Sticky sentences (sentence-level)
    if let Some(ref mut sticky) = report.sticky_sentences {
        sticky.sticky_sentences.retain(|s| {
            let line = sentence_map.get(s.sentence_num.saturating_sub(1)).copied().unwrap_or(0);
            !suppressions.is_suppressed("sticky_sentences", line)
        });
        sticky.sticky_count = sticky.sticky_sentences.iter().filter(|s| s.glue_percentage > 45.0).count();
        sticky.semi_sticky_count = sticky.sticky_sentences.iter().filter(|s| s.glue_percentage >= 35.0 && s.glue_percentage <= 45.0).count();
    }

    // Sentence length (sentence-level)
    if let Some(ref mut sl) = report.sentence_length {
        sl.very_long.retain(|s| {
            let line = sentence_map.get(s.sentence_num.saturating_sub(1)).copied().unwrap_or(0);
            !suppressions.is_suppressed("sentence_length", line)
        });
    }

    // Complex paragraphs (paragraph-level)
    if let Some(ref mut cp) = report.complex_paragraphs {
        cp.complex_paragraphs.retain(|p| {
            let line = paragraph_map.get(p.paragraph_num.saturating_sub(1)).copied().unwrap_or(0);
            !suppressions.is_suppressed("complex_paragraphs", line)
        });
        let total_paras = paragraph_map.len().max(1);
        cp.complex_count = cp.complex_paragraphs.len();
        cp.percentage = (cp.complex_count as f64 / total_paras as f64) * 100.0;
    }

    // Echoes (paragraph-level)
    if let Some(ref mut echoes) = report.echoes {
        echoes.echoes.retain(|e| {
            let line = paragraph_map.get(e.paragraph.saturating_sub(1)).copied().unwrap_or(0);
            !suppressions.is_suppressed("echoes", line)
        });
        echoes.total_echoes = echoes.echoes.len();
    }
}
```

**Step 4: Run tests to verify they pass**

Run: `cargo nextest run -E 'test(lint::)'`
Expected: all pass including new suppression tests.

**Step 5: Run full test suite**

Run: `cargo nextest run`
Expected: all pass.

**Step 6: Run clippy and fmt**

Run: `cargo fmt --all && cargo clippy --all-targets --all-features`

**Step 7: Commit**

```bash
git add crates/bito-lint-core/src/lint.rs
git commit -m "feat: region-level suppression filtering for grammar, sticky, length, paragraphs, echoes"
```

---

### Task 4: Custom Content — Config Struct and Resolution

**Files:**
- Modify: `crates/bito-lint-core/src/config.rs` (add `CustomEntry` struct, add `custom` field to `Config`)
- Modify: `crates/bito-lint-core/src/lib.rs` (re-export `CustomEntry`)
- Modify: `crates/bito-lint-core/src/error.rs` (add `CustomEntryError` variant)
- Test: `crates/bito-lint-core/src/config.rs`

**Step 1: Write failing tests**

Add to `mod tests` in `config.rs`:

```rust
#[test]
fn custom_entries_deserialize_from_yaml() {
    let yaml = r#"
custom:
  voice:
    instructions: "Write clearly and directly."
  house-style:
    file: "docs/style.md"
"#;
    let config: Config = serde_yaml::from_str(yaml).unwrap();
    let custom = config.custom.expect("custom should be present");
    assert_eq!(custom.len(), 2);
    let voice = custom.get("voice").unwrap();
    assert_eq!(voice.instructions.as_deref(), Some("Write clearly and directly."));
    assert!(voice.file.is_none());
    let style = custom.get("house-style").unwrap();
    assert!(style.instructions.is_none());
    assert_eq!(style.file.as_ref().unwrap().as_str(), "docs/style.md");
}

#[test]
fn custom_entries_default_to_none() {
    let config = Config::default();
    assert!(config.custom.is_none());
}

#[test]
fn resolve_custom_entry_inline() {
    let entry = CustomEntry {
        instructions: Some("Be concise.".to_string()),
        file: None,
    };
    let result = entry.resolve(Utf8Path::new("/tmp")).unwrap();
    assert_eq!(result, "Be concise.");
}
```

**Step 2: Run tests to verify they fail**

Expected: compile error — `CustomEntry` doesn't exist.

**Step 3: Add `CustomEntry` struct and config field**

Add to `config.rs` after `TokensRuleConfig` (around line 134):

```rust
/// A named custom content entry for plugin customization.
///
/// Plugins and agents read these entries at session start to inject
/// personas, voice guides, style rules, glossaries, etc. into context.
#[derive(Debug, Clone, Default, Deserialize, Serialize, PartialEq, Eq)]
#[serde(default)]
pub struct CustomEntry {
    /// Inline markdown instructions.
    pub instructions: Option<String>,
    /// Path to a markdown file (relative to config file location, or absolute).
    pub file: Option<Utf8PathBuf>,
}

impl CustomEntry {
    /// Resolve this entry to its content string.
    ///
    /// If `file` is set, reads the file (resolving relative paths against
    /// `config_dir`). Otherwise returns inline `instructions`.
    pub fn resolve(&self, config_dir: &Utf8Path) -> Result<String, ConfigError> {
        if let Some(ref file_path) = self.file {
            let resolved = if file_path.is_relative() {
                config_dir.join(file_path)
            } else {
                file_path.clone()
            };
            std::fs::read_to_string(resolved.as_std_path()).map_err(|e| {
                ConfigError::CustomEntryFile {
                    path: resolved,
                    source: e,
                }
            })
        } else if let Some(ref instructions) = self.instructions {
            Ok(instructions.clone())
        } else {
            Err(ConfigError::CustomEntryEmpty)
        }
    }
}
```

Add to `Config` struct (after `rules` field, around line 210):

```rust
/// Custom content entries for plugin customization.
///
/// Named markdown blobs (inline or file references) that plugins and agents
/// consume at session start. See `bito-lint custom show <name>`.
pub custom: Option<HashMap<String, CustomEntry>>,
```

**Step 4: Add error variants**

In `error.rs`, add to `ConfigError`:

```rust
/// A custom entry references a file that cannot be read.
#[error("custom entry file not found: {path}: {source}")]
CustomEntryFile {
    /// The resolved path that was attempted.
    path: Utf8PathBuf,
    /// The underlying IO error.
    source: std::io::Error,
},

/// A custom entry has neither `instructions` nor `file`.
#[error("custom entry has neither 'instructions' nor 'file'")]
CustomEntryEmpty,
```

Add `use camino::Utf8PathBuf;` to error.rs imports.

**Step 5: Re-export from lib.rs**

Add to `lib.rs` re-exports:

```rust
pub use config::CustomEntry;
```

**Step 6: Run tests**

Run: `cargo nextest run -E 'test(config::tests::custom_entries)' -E 'test(config::tests::resolve_custom)'`
Expected: all pass.

**Step 7: Commit**

```bash
git add crates/bito-lint-core/src/config.rs crates/bito-lint-core/src/error.rs crates/bito-lint-core/src/lib.rs
git commit -m "feat: add CustomEntry config struct with inline/file resolution"
```

---

### Task 5: Custom Content — CLI Subcommand

**Files:**
- Create: `crates/bito-lint/src/commands/custom.rs`
- Modify: `crates/bito-lint/src/commands/mod.rs:6-15` (add `pub mod custom;`)
- Modify: `crates/bito-lint/src/lib.rs:98-125` (add `Custom` variant to `Commands`)
- Modify: `crates/bito-lint/src/main.rs:78-118` (add `Commands::Custom` match arm)

**Step 1: Create the `custom` command module**

Create `crates/bito-lint/src/commands/custom.rs`:

```rust
//! Custom content command implementation.

use anyhow::Context;
use bito_lint_core::config::{Config, ConfigSources, CustomEntry};
use camino::Utf8Path;
use clap::{Args, Subcommand};
use owo_colors::OwoColorize;
use tracing::{debug, instrument};

/// Arguments for the `custom` subcommand.
#[derive(Args, Debug)]
pub struct CustomArgs {
    #[command(subcommand)]
    pub action: CustomAction,
}

/// Custom content actions.
#[derive(Subcommand, Debug)]
pub enum CustomAction {
    /// List all custom content entry names
    List,
    /// Show resolved content for a named entry
    Show {
        /// Name of the custom entry
        name: String,
    },
}

/// Execute the `custom` subcommand.
#[instrument(name = "cmd_custom", skip_all)]
pub fn cmd_custom(
    args: CustomArgs,
    global_json: bool,
    config: &Config,
    sources: &ConfigSources,
) -> anyhow::Result<()> {
    debug!("executing custom command");

    let config_dir = sources
        .primary_file()
        .and_then(|p| p.parent())
        .unwrap_or(Utf8Path::new("."));

    match args.action {
        CustomAction::List => cmd_list(global_json, config),
        CustomAction::Show { name } => cmd_show(&name, global_json, config, config_dir),
    }
}

fn cmd_list(global_json: bool, config: &Config) -> anyhow::Result<()> {
    let entries = config.custom.as_ref();

    if global_json {
        let names: Vec<&str> = entries
            .map(|m| m.keys().map(String::as_str).collect())
            .unwrap_or_default();
        println!("{}", serde_json::to_string_pretty(&names)?);
    } else {
        match entries {
            Some(map) if !map.is_empty() => {
                for name in map.keys() {
                    println!("{name}");
                }
            }
            _ => {
                println!("{}", "No custom entries defined in config.".dimmed());
            }
        }
    }
    Ok(())
}

fn cmd_show(
    name: &str,
    global_json: bool,
    config: &Config,
    config_dir: &Utf8Path,
) -> anyhow::Result<()> {
    let entries = config
        .custom
        .as_ref()
        .context("no custom entries defined in config")?;

    let entry = entries
        .get(name)
        .with_context(|| format!("custom entry '{name}' not found"))?;

    let content = entry
        .resolve(config_dir)
        .with_context(|| format!("failed to resolve custom entry '{name}'"))?;

    if global_json {
        let output = serde_json::json!({
            "name": name,
            "content": content,
        });
        println!("{}", serde_json::to_string_pretty(&output)?);
    } else {
        print!("{content}");
    }

    Ok(())
}
```

**Step 2: Register in `commands/mod.rs`**

Add `pub mod custom;` to the module list.

**Step 3: Add to `Commands` enum in `lib.rs`**

Add variant:

```rust
/// Manage custom content entries
Custom(commands::custom::CustomArgs),
```

**Step 4: Add match arm in `main.rs`**

In the `match command` block, add:

```rust
Commands::Custom(args) => {
    commands::custom::cmd_custom(args, cli.json, &config, &config_sources)
}
```

**Step 5: Run tests**

Run: `cargo nextest run`
Expected: all pass (existing + compilation checks).

**Step 6: Run clippy and fmt**

Run: `cargo fmt --all && cargo clippy --all-targets --all-features`

**Step 7: Commit**

```bash
git add crates/bito-lint/src/commands/custom.rs crates/bito-lint/src/commands/mod.rs crates/bito-lint/src/lib.rs crates/bito-lint/src/main.rs
git commit -m "feat: add 'custom' CLI subcommand (list/show)"
```

---

### Task 6: Custom Content — MCP Tool

**Files:**
- Modify: `crates/bito-lint/src/server.rs` (add `GetCustomParams`, `get_custom` tool, store config_dir)

**Step 1: Write failing test**

Add to `mod tests` in `server.rs`:

```rust
#[test]
fn get_custom_returns_inline_content() {
    use std::collections::HashMap;
    let mut custom = HashMap::new();
    custom.insert(
        "voice".to_string(),
        bito_lint_core::config::CustomEntry {
            instructions: Some("Be concise and direct.".to_string()),
            file: None,
        },
    );
    let config = bito_lint_core::Config {
        custom: Some(custom),
        ..Default::default()
    };
    let server = ProjectServer::new().with_config(config);
    let params = Parameters(GetCustomParams {
        name: "voice".to_string(),
    });

    let result = server.get_custom(params).expect("get_custom should succeed");
    assert!(!result.is_error.unwrap_or(false));
    let text = extract_text(&result).expect("should have text content");
    let json: serde_json::Value = serde_json::from_str(text).expect("valid JSON");
    assert_eq!(json["name"], "voice");
    assert!(json["content"].as_str().unwrap().contains("concise"));
}

#[test]
fn get_custom_not_found_returns_error() {
    let server = ProjectServer::new();
    let params = Parameters(GetCustomParams {
        name: "nonexistent".to_string(),
    });

    let result = server.get_custom(params);
    assert!(result.is_err());
}
```

**Step 2: Add params struct and tool**

Add params struct near other param structs:

```rust
/// Parameters for the `get_custom` tool.
#[derive(Debug, serde::Deserialize, schemars::JsonSchema)]
pub struct GetCustomParams {
    /// Name of the custom content entry to retrieve.
    pub name: String,
}
```

Add a `config_dir` field to `ProjectServer`:

```rust
pub struct ProjectServer {
    tool_router: rmcp::handler::server::router::tool::ToolRouter<Self>,
    max_input_bytes: Option<usize>,
    config: bito_lint_core::Config,
    config_dir: camino::Utf8PathBuf,
}
```

Update `new()`:

```rust
pub fn new() -> Self {
    Self {
        tool_router: Self::tool_router(),
        max_input_bytes: Some(core::DEFAULT_MAX_INPUT_BYTES),
        config: bito_lint_core::Config::default(),
        config_dir: camino::Utf8PathBuf::from("."),
    }
}
```

Add builder method:

```rust
pub fn with_config_dir(mut self, dir: camino::Utf8PathBuf) -> Self {
    self.config_dir = dir;
    self
}
```

Add tool method inside `#[tool_router] impl ProjectServer`:

```rust
/// Retrieve a custom content entry by name.
#[tool(
    description = "Get a custom content entry (persona, voice guide, style rules) defined in project config."
)]
#[tracing::instrument(skip(self), fields(otel.kind = "server", name = %params.name))]
fn get_custom(
    &self,
    #[allow(unused_variables)] Parameters(params): Parameters<GetCustomParams>,
) -> Result<CallToolResult, McpError> {
    tracing::debug!(tool = "get_custom", name = %params.name, "executing MCP tool");

    let entries = self.config.custom.as_ref().ok_or_else(|| {
        McpError::invalid_params("no custom entries defined in config".to_string(), None)
    })?;

    let entry = entries.get(&params.name).ok_or_else(|| {
        let available: Vec<&str> = entries.keys().map(String::as_str).collect();
        McpError::invalid_params(
            format!(
                "custom entry '{}' not found. Available: {}",
                params.name,
                available.join(", ")
            ),
            None,
        )
    })?;

    let content = entry.resolve(&self.config_dir).map_err(|e| {
        McpError::internal_error(format!("failed to resolve custom entry: {e}"), None)
    })?;

    let output = serde_json::json!({
        "name": params.name,
        "content": content,
    });

    let json = serde_json::to_string_pretty(&output)
        .map_err(|e| McpError::internal_error(format!("serialization error: {e}"), None))?;

    tracing::info!(tool = "get_custom", name = %params.name, "MCP tool completed");
    Ok(CallToolResult::success(vec![Content::text(json)]))
}
```

**Step 3: Wire config_dir in `main.rs` serve command**

In `main.rs`, update the serve command to pass config_dir. Find the `Commands::Serve` match arm and update `cmd_serve` to accept and pass the config dir from `config_sources.primary_file()`.

Check `commands/serve.rs` for the `cmd_serve` signature and update it to accept a config_dir parameter, passing it to `ProjectServer::new().with_config_dir(...)`.

**Step 4: Run tests**

Run: `cargo nextest run -E 'test(server::tests::get_custom)'`
Expected: all pass.

**Step 5: Update MCP token budget test**

The `mcp_tool_schemas_fit_token_budget` test asserts ≤4000 tokens. Adding `get_custom` adds ~250-300 tokens. If the test fails, increase the budget to 4500.

**Step 6: Run full test suite, clippy, fmt**

Run: `cargo nextest run && cargo fmt --all && cargo clippy --all-targets --all-features`

**Step 7: Commit**

```bash
git add crates/bito-lint/src/server.rs crates/bito-lint/src/main.rs crates/bito-lint/src/commands/serve.rs
git commit -m "feat: add get_custom MCP tool for retrieving custom content entries"
```

---

### Task 7: Update Example Configs and Docs

**Files:**
- Modify: `config/bito-lint.yaml.example`
- Modify: `config/bito-lint.toml.example`
- Modify: `docs/README.md` (add custom command, .bito discovery, suppression docs)

**Step 1: Update YAML example**

Add to `config/bito-lint.yaml.example` after the rules section:

```yaml
# ------------------------------------------------------------------------------
# Custom Content Entries
# ------------------------------------------------------------------------------

# Define named content entries that plugins and agents consume at session start.
# Each entry is a name mapping to either inline instructions or a file path.
# If both are set, the file takes precedence.
#
# Plugins define which entry names they look for. Users populate those names
# in their config. No forking required.

# custom:
#   voice:
#     file: "docs/voice-and-tone.md"
#   house-style:
#     instructions: |
#       - Always use Oxford comma
#       - Prefer "we" over "I"
#       - Technical terms: lowercase unless proper noun
#   glossary:
#     file: "docs/glossary.md"
```

Update the config file discovery header to mention `.bito` names.

**Step 2: Update TOML example with same content**

Add equivalent TOML syntax.

**Step 3: Update docs/README.md**

Add `custom` command to the commands section. Update the suppression directives section to document region-level filtering behavior. Add `.bito` config file names to the discovery section.

**Step 4: Commit**

```bash
git add config/bito-lint.yaml.example config/bito-lint.toml.example docs/README.md
git commit -m "docs: update configs and README for v0.3 features"
```

---

### Task 8: Final Validation

**Step 1: Run full check suite**

Run: `just check`
Expected: fmt + clippy + deny + test + doc-test all pass.

**Step 2: Verify CLI works end-to-end**

```bash
cargo run -- custom list
cargo run -- custom show voice  # (with a test config)
cargo run -- info --json
```

**Step 3: Verify suppression works end-to-end**

Create a test markdown file with suppression directives and run `cargo run -- lint <file>` against it.
